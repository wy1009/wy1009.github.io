<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JavaScript,React.js,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="不可变性（immutability）可能是个令人困惑的话题，它总会在 React、Redux 和 JavaScript 中到处出现。 你可能碰到过已经更改了 props，但 React 组件不重新渲染的 bug。有人说：“你应该做不可改变状态（immutable state）的更新。”可能你或者你的同事经常写改变状态（mutate state）的 Redux reducers，且你不得不不断纠正这">
<meta name="keywords" content="JavaScript,React.js">
<meta property="og:type" content="article">
<meta property="og:title" content="React 和 Redux 中的不可变性：全面指引">
<meta property="og:url" content="http://yoursite.com/2018/10/16/immutability-in-react-and-redux/index.html">
<meta property="og:site_name" content="不会化妆的写手&lt;br&gt;不是好程序员">
<meta property="og:description" content="不可变性（immutability）可能是个令人困惑的话题，它总会在 React、Redux 和 JavaScript 中到处出现。 你可能碰到过已经更改了 props，但 React 组件不重新渲染的 bug。有人说：“你应该做不可改变状态（immutable state）的更新。”可能你或者你的同事经常写改变状态（mutate state）的 Redux reducers，且你不得不不断纠正这">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/memory-box-1.png">
<meta property="og:image" content="http://yoursite.com/images/memory-box-2.png">
<meta property="og:image" content="http://yoursite.com/images/memory-box-3.png">
<meta property="og:updated_time" content="2020-06-30T14:04:59.933Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React 和 Redux 中的不可变性：全面指引">
<meta name="twitter:description" content="不可变性（immutability）可能是个令人困惑的话题，它总会在 React、Redux 和 JavaScript 中到处出现。 你可能碰到过已经更改了 props，但 React 组件不重新渲染的 bug。有人说：“你应该做不可改变状态（immutable state）的更新。”可能你或者你的同事经常写改变状态（mutate state）的 Redux reducers，且你不得不不断纠正这">
<meta name="twitter:image" content="http://yoursite.com/images/memory-box-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/16/immutability-in-react-and-redux/">





  <title>React 和 Redux 中的不可变性：全面指引 | 不会化妆的写手<br>不是好程序员</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a17a483691d457feb9d048db3e29684c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会化妆的写手<br>不是好程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/16/immutability-in-react-and-redux/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="泉先">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会化妆的写手<br>不是好程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">React 和 Redux 中的不可变性：全面指引</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-16T16:41:29+08:00">
                2018-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/框架-库-工具/" itemprop="url" rel="index">
                    <span itemprop="name">框架/库/工具</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/框架-库-工具/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>不可变性（immutability）可能是个令人困惑的话题，它总会在 React、Redux 和 JavaScript 中到处出现。</p>
<p>你可能碰到过已经更改了 props，但 React 组件不重新渲染的 bug。有人说：“你应该做不可改变状态（immutable state）的更新。”可能你或者你的同事经常写改变状态（mutate state）的 Redux reducers，且你不得不不断纠正这些（reducers，或者你的同事😄）。</p>
<p>纠正这个很棘手。它真的很微妙，特别是如果你不确定为什么要纠正。况且说真的，如果你不确定为什么这很重要，那就很难去在意它。</p>
<p>这份导航会解释“不可变性”是什么，以及如果在你自己的应用中写不可变性的代码。</p>
<h2 id="不可变性是什么"><a href="#不可变性是什么" class="headerlink" title="不可变性是什么"></a>不可变性是什么</h2><p>首先，“不可变”是“可变”的反义词——“可变”意味着可以变化，可能会出问题。</p>
<p>所以某个东西是不可变的，就是说，这个东西不能够被改变。</p>
<p>极端的讲，这意味着比起传统地直接改变值，你应该始终创建新的值去取代旧的值。JavaScript 没有这么极端，但是一些语言完全不允许“可变”（Elixir、Erlang、ML 等等）。</p>
<p>尽管 JavaScript 不是纯粹的函数式语言，但它有时候可以假装是。在 JS 中，某些数组操作是不可变的（就是返回一个新数值，而不是修改原本的）。字符串操作总是不可变的（变化会创建一个新字符串）。并且，你也可以自己写不可变的函数。你只需要意识到一些规则。</p>
<a id="more"></a>
<h2 id="改变（mutation）的代码示例"><a href="#改变（mutation）的代码示例" class="headerlink" title="改变（mutation）的代码示例"></a>改变（mutation）的代码示例</h2><p>我们可以通过一个例子来看可变性是怎样的。比如以下这个 <code>person</code> 对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'Bob'</span>,</span><br><span class="line">  lastName: <span class="string">'Loblaw'</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    street: <span class="string">'123 fake St'</span>,</span><br><span class="line">    city: <span class="string">'Emberton'</span>,</span><br><span class="line">    state: <span class="string">'NJ'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们写一个函数，给这个人赋予超能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveAwesomePowers</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.specialPower = <span class="string">'invisibility'</span></span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，这样，每个人都得到了同样的超能力。不管怎么样，隐身是很棒的！</p>
<p>让我们给 Loblaw 先生赋予超能力：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚开始，Bob 没有超能力 :(</span></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着，我们调用函数</span></span><br><span class="line"><span class="keyword">let</span> samePerson = giveAwesomePowers(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，Bob 有超能力了！</span></span><br><span class="line"><span class="built_in">console</span>.log(Bob)</span><br><span class="line"><span class="built_in">console</span>.log(samePerson)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管如此，在其他方面，他仍旧是同一个人</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Are they the same?'</span>, person === samePerson) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>giveAwesomePowers</code> 函数改变了传入其中的 <code>person</code>。运行这段代码，你能看到，我们第一次打印 <code>person</code>，Bob 没有 <code>specialPower</code> 属性。然而接下来，第二次，他突然有了隐身的 <code>specialPower</code>。</p>
<p>也就是说，在这个函数改变了传入的 <code>person</code> 之后，我们就再也不知道以前的 <code>person</code> 是什么样子了。它被永远地改变了。</p>
<p><code>giveAwesomePowers</code> 返回的对象和传入 <code>giveAwesomePowers</code> 的对象是同一个，但是这个对象里面已经被搞乱了，它的属性已经被改变了。它已经被改变（be mutated）了。</p>
<p>因为很重要，我想再说一次：这个对象里面已经被改变了，但是这个对象的引用没有变。它和外面的对象是同一个对象（所以检查是否相等的 <code>person === samePerson</code> 的结果是 <code>true</code>）。</p>
<p>如果我们不想让 <code>giveAwesomePowers</code> 函数改变 <code>person</code>，我们需要做一些改动。不管怎么样，我们先看看是什么让一个函数变得纯粹（pure），因为它和不可变性密切相关。</p>
<h2 id="不可变性的规则"><a href="#不可变性的规则" class="headerlink" title="不可变性的规则"></a>不可变性的规则</h2><p>要使一个函数纯粹，需要遵循以下规则：</p>
<ol>
<li>输入相同的值，纯函数会永远返回相同的值；</li>
<li>纯函数不产生任何副作用。</li>
</ol>
<h2 id="什么是“副作用”"><a href="#什么是“副作用”" class="headerlink" title="什么是“副作用”"></a>什么是“副作用”</h2><p>“副作用”是一个意思很广的术语，但基本上，它意味着修改了直接函数的范围之外的东西。举一些例子：</p>
<ul>
<li>改变传入的参数，像 <code>giveAwesomePowers</code> 一样；</li>
<li>改变任何函数外面的值，比如全局变量，或者 <code>document</code>/<code>window</code> 上的值；</li>
<li>调用 API；</li>
<li><code>console.log()</code></li>
<li><code>Math.random()</code></li>
</ul>
<p>调用 API 这条可能让人比较意外。毕竟，调用像是 <code>fetch(&#39;/users&#39;)</code> 好像根本不会改变 UI。但是，如果你调用了 <code>fetch(&#39;/users&#39;)</code>，它真的不会改变任何地方吗？比如 UI 之外呢？</p>
<p>实际上，它会在浏览器的网络日志中创建一条日志。它会创建（且过会可能会关闭）一个与服务器的网络连接。且一旦连上了服务器，服务器可以做任何它想做的事，包括唤起其他服务做更多改变。最少最少，它也会在日志文件中记一条日志（这也是一个改变）。</p>
<p>所以说，“副作用”是一个含义很广的属于。</p>
<p>下面是一个没有副作用的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以调用它一次，也可以调用一百万次，但世界上任何其他的东西都不会因此而改变。这符合规则 2：没有副作用。</p>
<p>另外，每次你调用这个函数，比如 <code>add(1, 2)</code>，你都会得到同样的答案。不管你调用多少次 <code>add(1, 2)</code>，都会得到同样的答案。这符合规则 1：同样的输入得到同样的输出。</p>
<h2 id="会改变的-JS-数组方法"><a href="#会改变的-JS-数组方法" class="headerlink" title="会改变的 JS 数组方法"></a>会改变的 JS 数组方法</h2><p>某些数组方法会改变数组：</p>
<ul>
<li>push（在尾部添加一项）</li>
<li>pop（从尾部移除一项）</li>
<li>shift（从头部移除一项）</li>
<li>unshift（在头部添加一项）</li>
<li>sort</li>
<li>reverse</li>
<li>splice</li>
</ul>
<p>是的，JS 数组的 <code>sort</code> 方法不是不可变的！它会原地重排数组。</p>
<p>如果你需要做这些操作，最简单的方法就是先复制出一个数组，然后在复制出的数组上做操作。你可以用以下方法复制一个数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> copy1 = [...a]</span><br><span class="line"><span class="keyword">let</span> copy2 = a.slice()</span><br><span class="line"><span class="keyword">let</span> copy3 = a.concat()</span><br></pre></td></tr></table></figure>
<p>所以，如果你想在数组上做一个不可变的排序，你可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedArray = [...originalArray].sort(compareFunction)</span><br></pre></td></tr></table></figure>
<p>另外，有一个小拓展（之前坑了我一次），<code>compareFunction</code> 需要返回 0、1 或者 -1，而不是布尔值。</p>
<h2 id="纯函数只能调用纯函数"><a href="#纯函数只能调用纯函数" class="headerlink" title="纯函数只能调用纯函数"></a>纯函数只能调用纯函数</h2><p>一个可能造成问题的做法是，在纯函数中调用非纯函数。</p>
<p>纯粹性要么有，要么没有。如果你写了一个完美的纯函数，但是在结尾调用了其他函数，而这个被调用的函数调用了 <code>setState</code>、<code>dispatch</code> 或者引起了其他副作用，那你就前功尽弃了。</p>
<p>现在，有些副作用是“可接受的”。用 <code>console.log</code> 记录日志就没关系。是的，技术上讲，这是一个副作用，但是它不会影响任何东西。</p>
<h2 id="纯函数版本的-giveAwesomePowers"><a href="#纯函数版本的-giveAwesomePowers" class="headerlink" title="纯函数版本的 giveAwesomePowers"></a>纯函数版本的 <code>giveAwesomePowers</code></h2><p>现在，我们可以用我们心里的规则重写这个方法了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveAwesomePowers</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newPerson = <span class="built_in">Object</span>.assign(&#123;&#125;, person, &#123;</span><br><span class="line">    specialPower: <span class="string">'invisibility'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newPerson</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有一点不同了。我没没有改变 <code>person</code>，而是创建了一个全新的 <code>person</code>。</p>
<p>如果你没见过 <code>Object.assign</code>，它的作用是把一个对象的属性复制到另一个对象上。你可以向其中传入一系列的对象，它会将它们都合并到一起，从左到右，重复的属性会被重写。（从左到右，指的是执行 <code>Object.assign(result, a, b, c)</code>，会把 <code>a</code> 复制到 <code>result</code> 上，然后是 <code>b</code>，然后是 <code>c</code>）。</p>
<p>但它做的不是深合成。它只会直接原样复制每个参数的子属性，不会为属性创建副本。</p>
<p>另一种借用 <code>...</code> 运算符的写法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveAwesomePowers</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newPerson = &#123;</span><br><span class="line">    ...person,</span><br><span class="line">    specialPower: <span class="string">'invisibility'</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newPerson</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="纯函数返回全新的对象"><a href="#纯函数返回全新的对象" class="headerlink" title="纯函数返回全新的对象"></a>纯函数返回全新的对象</h2><p>现在，我们可以用我们纯函数版本的 <code>giveAwesomePowers</code> 重新跑一遍我们之前的代码了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 刚开始，Bob 没有超能力 :(</span></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着，我们调用函数</span></span><br><span class="line"><span class="keyword">let</span> samePerson = giveAwesomePowers(person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，Bob 的克隆体有超能力了！</span></span><br><span class="line"><span class="built_in">console</span>.log(Bob)</span><br><span class="line"><span class="built_in">console</span>.log(samePerson)</span><br><span class="line"></span><br><span class="line"><span class="comment">// newPerson 是一个克隆体</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Are they the same?'</span>, person === samePerson) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这与之前有很大的不同，<code>person</code> 没有被改变。Bob 没有变。这个函数创造了一个 Bob 的克隆体，有全部相同的属性，加上了能够隐身的能力。</p>
<p>这是函数式编程比较奇怪的地方。对象不断被创建和销毁。我们没有改变 Bob，我们创建了一个 Bob 的克隆体，更改这个克隆体，然后用这个克隆体替换了 Bob。确实有点恐怖。如果你看过一部叫《The Prestige》的电影，这个和它有点像。</p>
<h2 id="React-更喜欢不可变性"><a href="#React-更喜欢不可变性" class="headerlink" title="React 更喜欢不可变性"></a>React 更喜欢不可变性</h2><p>在 React 的案例中，永远不要直接改变 state 和 props 是很重要的，不管组件是函数还是类都是这样。如果你要写类似 <code>this.state.something = ...</code> 或 <code>this.props.something = ...</code> 的代码，退一步然后试着想想更好的方法。</p>
<p>如果要改变 state，通常使用 <code>this.setState</code>。更多的信息可以阅读<a href="https://daveceddia.com/why-not-modify-react-state-directly/" target="_blank" rel="noopener">《为什么不能直接改变 state》</a>。</p>
<p>至于 props，他们是单向的。props 被传入一个组件，但不存在双向通路，至少不能做类似把一个 prop 设为新值的可变的操作。</p>
<p>如果你需要把一些数据传递回父组件，或者在父组件引发一些操作，你可以将一个方法作为 prop 传入子组件，然后在需要与父组件交流的时候，在子组件中调用这个方法。这是一个小例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当按钮被点击时，父组件传入的方法会被调用</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;props.printMessage&#125;&gt;Click Me!<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'you click the button'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父组件传递一个函数给子组件作为 prop</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Child onClick=&#123;printMessage&#125; /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不可变性对于-PureComponents-而言很重要"><a href="#不可变性对于-PureComponents-而言很重要" class="headerlink" title="不可变性对于 PureComponents 而言很重要"></a>不可变性对于 <code>PureComponents</code> 而言很重要</h2><p>默认来说，React 组件（不管是函数组件还是类组件，只要继承于 <code>React.Component</code> 都会）会在你调用 <code>setState</code>，或者父组件重新渲染的时候重新渲染。</p>
<p>一个简单的优化 React 组件性能的方法是，使其成为类组件，然后让其继承于 <code>React.PureComponent</code>，而不是 <code>React.Component</code>。这样，这个组件将只在它的 state 或者 props 改变的时候重新渲染，而不再会无脑地在每次它的父组件重新渲染的时候重新渲染。</p>
<p>这就是不可变性的来源：如果你要向一个 <code>PureComponent</code> 中传递 props，你必须得确定这些 props 都是以不可变的方式更新的。也就是说，如果 props 是对象或者数组，你需要用一个新的（更改过的）对象或数组去替换掉原来的。就像 Bob，杀死他，然后用一个克隆体替换他。</p>
<p>如果你更改了一个对象或者数组的内部——比如更改一个属性，或者推入了新的一项，或者更改了数组中的一项——那么这个对象或数组在引用上仍旧等于旧的自己，所以一个 <code>PureComponent</code> 不会注意到它已经改变了，也就不会重新渲染。奇怪的渲染 bug 也就出现了。</p>
<p>记得我们第一个 Bob 和 <code>giveAwesomePowers</code> 函数的例子吗？函数返回的对象完全等于传入的那个。这是因为两个变量都引用了同一个对象，只是内部被改变了。</p>
<h2 id="引用相等在-JavaScript-中是如何运行的？"><a href="#引用相等在-JavaScript-中是如何运行的？" class="headerlink" title="引用相等在 JavaScript 中是如何运行的？"></a>引用相等在 JavaScript 中是如何运行的？</h2><p>“引用相等（Referential Equality）”指的是什么？理解这个很重要。</p>
<p>JavaScript 对象和数组是被储存在内存中的。让我们假设内存里的位置就像盒子。变量名指向盒子，而盒子保存着实际的值。</p>
<p><img src="/images/memory-box-1.png" alt="内存”盒子“"></p>
<p>在 JavaScript 中，这些盒子（内存地址）是未命名且不可知的。你无法看到一个变量实际指向的内存地址。（在一些其他语言中，比如 C，你可以实际地检查变量的内存地址并查看它的位置。）</p>
<p>如果你重新给变量赋值，变量会指向一个新的内存位置。</p>
<p><img src="/images/memory-box-2.png" alt="内存”盒子“"></p>
<p>如果你改变了这个变量的内部，变量仍会指向原本的地址。</p>
<p><img src="/images/memory-box-3.png" alt="内存”盒子“"></p>
<p>就像是重新装修房子，哪怕装上了新的墙、厨房、卧室或者游泳池，这个房子的地址仍旧是不变的。你没必要提醒亲戚往哪里寄礼物，因为你仍就住在同样的地方。</p>
<p><strong>这是重点：</strong>当你用 <code>===</code> 操作符比较两个对象或者数组时，JavaScript 实际上比较的是他们指向的地址，也就是它们的引用。JS 不会看这个对象的内部。这也就是”引用相等“的意思。</p>
<p>所以，如果你改变一个对象，你改变的是这个对象的内容，而不会改变它的引用。</p>
<p>另外，如果你把一个对象赋值为另一个对象（或者把它作为一个函数的参数传入，这做的实际上是同一件事），另一个对象只是指向了同样的内存位置，和第一个对象一样。就像巫毒娃娃一样，你对第二个对象做的操作也会直接影响到第一个对象的值。</p>
<p>具体参见下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个变量 `crayon`，指向一个盒子（未命名），盒子中保存着对象 `&#123; color: 'red' &#125;`</span></span><br><span class="line"><span class="keyword">let</span> crayon = &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 `crayon` 的一个属性不会改变它指向的是哪个盒子</span></span><br><span class="line">crayon.color = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个变量赋值为另一个对象或者数组，只是把新变量的指向指到了同样的一个盒子上</span></span><br><span class="line"><span class="keyword">let</span> crayon2 = crayon</span><br><span class="line"><span class="built_in">console</span>.log(crayon2 === crayon)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，任何对 `crayon2` 的更改也会影响 `crayon`</span></span><br><span class="line">crayon2.color = <span class="string">'green'</span></span><br><span class="line"><span class="built_in">console</span>.log(crayon.color) <span class="comment">// 改为 green</span></span><br><span class="line"><span class="built_in">console</span>.log(crayon2.color) <span class="comment">// 也变成了绿色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为这两个变量在内存中指向同一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(crayon2 === crayon) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="为什么不深入比较是否相等呢？"><a href="#为什么不深入比较是否相等呢？" class="headerlink" title="为什么不深入比较是否相等呢？"></a>为什么不深入比较是否相等呢？</h2><p>在声明两个对象相等之前，先检查它们的内部看起来更加“正确”。虽然确实是这样，但是太慢了。</p>
<p>有多慢呢？这取决于被比较的对象。有一万个子属性和孙属性的对象肯定比只有两个属性的对象要慢。这是不可预测的。</p>
<p>引用相等的检查被称为“恒定时间”。恒定时间，也就是 O(1)，意味着这个操作永远消耗相同的时间，不管输入的有多大。</p>
<p>而深入检查是否相等则更像是“线性时间”，也就是 O(N)，意味着消耗的时间和对象的属性数量是成比例的。线性时间一般来讲是慢于恒定时间的。</p>
<p>可以这样想，假装 JS 每次对比两个值，比如 <code>a === b</code> 都要花上一整秒。现在，你是想要只比较一次，只比较引用，还是想要深入检查两个对象，比较每个属性呢？第二种听起来很慢吧？</p>
<p>现实中，对比一次是否相等要比一整秒快得多得多，但是，“尽可能做最少的工作”的原则仍旧适用。其他条件相同时，使用性能最高的选项，可以让你少花点时间寻找你的 app 为什么这么慢。如果你足够小心（且比较幸运），可能根本就不会慢。</p>
<h2 id="const-能阻止改变吗？"><a href="#const-能阻止改变吗？" class="headerlink" title="const 能阻止改变吗？"></a><code>const</code> 能阻止改变吗？</h2><p>简单说：不会。不管是 <code>let</code> 还是 <code>const</code> 或者 <code>var</code> 都不会阻止你改变一个对象的内部。这三种声明变量的方式都允许你更改其内部。</p>
<p>“但是它被称为‘常量（<code>const</code>）’！它应该一直不变呀！”</p>
<p>一般来说是这样。但 <code>const</code> 只会阻止你重新分配引用，而不会阻止你改变这个对象。这是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> order = &#123; type = <span class="string">'coffee'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 允许更改 order 的 type</span></span><br><span class="line">order.type = <span class="string">'tea'</span> <span class="comment">// 这样没关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 不允许给 `order` 重新分配引用</span></span><br><span class="line">order = &#123; <span class="attr">type</span>: <span class="string">'tea'</span> &#125; <span class="comment">// 这样会出错</span></span><br></pre></td></tr></table></figure>
<p>我喜欢用 <code>const</code> 来提醒我自己一个对象或者数组不应该被更改（大多数情况下都是这样的）。如果写代码的时候，我明确知道我会更改某个对象或者数组，我会用 <code>let</code> 声明它。这只是一个习惯性的规则。</p>
<h2 id="在-Redux-中要如何更新-state-呢？"><a href="#在-Redux-中要如何更新-state-呢？" class="headerlink" title="在 Redux 中要如何更新 state 呢？"></a>在 Redux 中要如何更新 state 呢？</h2><p>Redux 要求 reducers 都是纯函数。也就是说，你不能直接更改 state，你必须基于原本的 state 创建一个新的 state，就像我们上面对 Bob 做的一样。（如果你不相信，可以看看 <a href="https://daveceddia.com/what-is-a-reducer/" target="_blank" rel="noopener">reducer 是什么</a>以及这个名字的来源是什么。）</p>
<p>写不可变的状态更新可能很复杂。下面，你可以找到一些常见的模式。</p>
<p>可以在浏览器控制台或者实际项目里自己动手试试。我觉得嵌套对象的更新是最难得，要特别注意并多加练习。</p>
<p>这些实际上也全部适用于 React 的 state，所以你在这份教程里学到的不仅仅适用于 Redux。</p>
<p>在最后，我们会看看怎么使用 Immer 库让这些更方便——但是不要直接跳到结尾！如果你打算使用现有的代码库，那么理解原理非常有用处。</p>
<h2 id="…-扩展操作符"><a href="#…-扩展操作符" class="headerlink" title="… 扩展操作符"></a>… 扩展操作符</h2><p>很多例子经常对对象或者数组使用扩展操作符，以下是它的执行过程。</p>
<p>当 <code>...</code> 符号被写在对象或者数组的前面，它会展开对象或者数组的子属性，然后就把他们插入到原地。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newNums = [...nums] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">nums === newNums <span class="comment">// false。newNums 是一个新的数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'Liz'</span>, <span class="attr">age</span>: <span class="number">32</span> &#125;</span><br><span class="line"><span class="keyword">let</span> newPerson = &#123; ...person &#125;</span><br><span class="line">person === newPerson <span class="comment">// false。newPerson 是一个新的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部属性保持不变</span></span><br><span class="line"><span class="keyword">let</span> company = &#123;</span><br><span class="line">  name: <span class="string">'Foo Corp'</span>,</span><br><span class="line">  people: [&#123; <span class="attr">name</span>: <span class="string">'Joe'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'Alice'</span> &#125;],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCompany = &#123; ...company &#125;</span><br><span class="line">company === newCompany <span class="comment">// false。newCompany 是一个新的对象。</span></span><br><span class="line">company.people === newCompany.people <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>像上面这样，扩展操作符很方便就能创建一个和另一个对象/数组属性相同的新对象/数组。你可以轻松创建一个对象/数组的副本，然后重写你需要改变的特定属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> liz = &#123;</span><br><span class="line">  name: <span class="string">'Liz'</span>,</span><br><span class="line">  age: <span class="number">32</span>,</span><br><span class="line">  location: &#123;</span><br><span class="line">    city: <span class="string">'Portland'</span>,</span><br><span class="line">    state: <span class="string">'Oregon'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  pets: [&#123; <span class="attr">type</span>: <span class="string">'cat'</span>, <span class="attr">name</span>: <span class="string">'Redux'</span> &#125;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// liz 长大了一岁，其他的信息都没有改变</span></span><br><span class="line"><span class="keyword">let</span> olderLiz = &#123;</span><br><span class="line">  ...liz,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ES2018 开始，扩展操作符是标准 JavaScript 的一部分。</p>
<h2 id="更新-state-的诀窍"><a href="#更新-state-的诀窍" class="headerlink" title="更新 state 的诀窍"></a>更新 state 的诀窍</h2><p>这些例子写的都是 Redux reducer，我会展示传入的 state 的样子，然后展示如何返回一个更新过的 state。</p>
<p>为了让例子更简洁，我会完全省略掉”action“参数。我们假装 state 更新会在所有 action 到来时触发。当然，在你自己的 reducers 中，可能会有 <code>switch</code> 声明以及针对每个 action 的 <code>case</code>，在这里我也都省略掉了。</p>
<h3 id="在-React-中更新组件中的-state"><a href="#在-React-中更新组件中的-state" class="headerlink" title="在 React 中更新组件中的 state"></a>在 React 中更新组件中的 state</h3><p>如果要把这些例子用在更新 React 组件中的 state 上，只需要在例子上简单调整一下。</p>
<p>因为 React 会浅合并你传入 <code>this.setState()</code> 中的对象，你没必要像在 Redux 中那样用扩展操作符操作原本的 state。</p>
<p>在 Redux reducer 中，你可能这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ...state,</span><br><span class="line">  (updates here),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要更新组件中的 state，只需要这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  updates here,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>记住，尽管 <code>setState</code> 会做一个浅合并，但如果你要更新 state 中深层嵌套的属性（只要比第一层深），你还是需要使用扩展操作符。</p>
<h2 id="Redux：更新对象"><a href="#Redux：更新对象" class="headerlink" title="Redux：更新对象"></a>Redux：更新对象</h2><p>如果你想要更新 Redux state 的第一层属性，用 <code>...state</code> 复制原有的 state，然后列出你想要改变的属性和它们新的值就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = &#123;</span></span><br><span class="line"><span class="comment">      clicks: 0,</span></span><br><span class="line"><span class="comment">      count: 0</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">    clicks: state.clicks + <span class="number">1</span>,</span><br><span class="line">    count: state.count - <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux-更新对象中的对象"><a href="#Redux-更新对象中的对象" class="headerlink" title="Redux: 更新对象中的对象"></a>Redux: 更新对象中的对象</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>如果你想要更新的对象没有在 Redux state 的第一层，你需要制作每一层的副本，包括你想要更新的那个对象。下面是例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = &#123;</span></span><br><span class="line"><span class="comment">      house: &#123;</span></span><br><span class="line"><span class="comment">        name: 'Ravenclaw',</span></span><br><span class="line"><span class="comment">        points: 17,</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给拉文克劳加两分</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">    house: &#123;</span><br><span class="line">      ...state.house,</span><br><span class="line">      points: state.house.points + <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子，更新更深一层：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = &#123;</span></span><br><span class="line"><span class="comment">      school: &#123;</span></span><br><span class="line"><span class="comment">        name: 'Hogwarts', // 复制 state</span></span><br><span class="line"><span class="comment">        house: &#123;</span></span><br><span class="line"><span class="comment">          name: 'Ravenclaw', // 复制嵌套的 object</span></span><br><span class="line"><span class="comment">          points: 17</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给拉文克劳加两分</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state, <span class="comment">// 复制 state</span></span><br><span class="line">    school: &#123;</span><br><span class="line">      ...state.school, <span class="comment">// 复制第一层</span></span><br><span class="line">      house: &#123;         <span class="comment">// 替换 state.school.house</span></span><br><span class="line">        ...state.school.house, <span class="comment">// 复制原本 house 的属性</span></span><br><span class="line">        points: state.school.house.points + <span class="number">2</span>  <span class="comment">// 更改属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在更新深层嵌套的属性时，代码会变得很难阅读。</p>
<h2 id="Redux：按照属性名更新对象"><a href="#Redux：按照属性名更新对象" class="headerlink" title="Redux：按照属性名更新对象"></a>Redux：按照属性名更新对象</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    const state = &#123;</span></span><br><span class="line"><span class="comment">      houses: &#123;</span></span><br><span class="line"><span class="comment">        gryffindor: &#123;</span></span><br><span class="line"><span class="comment">          points: 15</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        ravenclaw: &#123;</span></span><br><span class="line"><span class="comment">          points: 18</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        hufflepuff: &#123;</span></span><br><span class="line"><span class="comment">          points: 7</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        slytherin: &#123;</span></span><br><span class="line"><span class="comment">          points: 5,</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给拉文克劳加三分，学院名已经被存入了一个变量中</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="string">'ravenclaw'</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state, <span class="comment">// 复制 state</span></span><br><span class="line">    houses: &#123;</span><br><span class="line">      ...state.houses, <span class="comment">// 复制 houses</span></span><br><span class="line">      [key]: &#123; <span class="comment">// 更新具体的 house</span></span><br><span class="line">        ...state.houses[key], <span class="comment">// 复制 house 的属性</span></span><br><span class="line">        points: state.houses[key].points + <span class="number">3</span>, <span class="comment">// 更新 point 属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：在数组头部插入一项"><a href="#Redux：在数组头部插入一项" class="headerlink" title="Redux：在数组头部插入一项"></a>Redux：在数组头部插入一项</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>如果要用可变的方法做这件事，就是使用数组的 <code>.unshift()</code> 方法在前面增加一项。<code>Array.prototype.unshift</code> 会改变数组，这不是我们想看到的。</p>
<p>下面是在数组头部插入一项的不可变的做法，适用于 Redux：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [1, 2, 3];</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newItem = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> [ <span class="comment">// 一个新数组</span></span><br><span class="line">    newItem, <span class="comment">// 在头部增加一项</span></span><br><span class="line">    ...state, <span class="comment">// 把原本的 state 在尾部展开</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：在数组尾部插入一项"><a href="#Redux：在数组尾部插入一项" class="headerlink" title="Redux：在数组尾部插入一项"></a>Redux：在数组尾部插入一项</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>做这件事的可变方法是使用数组的 <code>.push</code> 方法在尾部增加一项。但是会改变数组。</p>
<p>下面是在数组尾部插入一项的不可变的做法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [1, 2, 3];</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newItem = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> [ <span class="comment">// 新数组</span></span><br><span class="line">    ...state, <span class="comment">// 先把原本的 state 展开</span></span><br><span class="line">    newItem, <span class="comment">// 把新的一项插入到最后</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以先用 <code>.slice</code> 创建一个数组的副本，然后改变这个副本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newItem = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> newState = state.slice()</span><br><span class="line"></span><br><span class="line">  newState.push(newItem)</span><br><span class="line">  <span class="keyword">return</span> newState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：使用-map-更新数组中的一项"><a href="#Redux：使用-map-更新数组中的一项" class="headerlink" title="Redux：使用 map 更新数组中的一项"></a>Redux：使用 <code>map</code> 更新数组中的一项</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>数组的 <code>.map</code> 方法会返回一个新的数组。其规则是，调用你提供的函数，把数组中的每一项传入函数，然后把返回值作为这一项新的值。</p>
<p>也就是说，如果你有一个 N 项的数组，然后想要一个仍旧有 N 项的新数组，使用 <code>.map</code>。你可以利用传入的函数更新/替换一项或是多项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [1, 2, 'X', 4]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 把 X 替换为 3</span></span><br><span class="line">    <span class="comment">// alternatively: you could look for a specific index</span></span><br><span class="line">    <span class="keyword">if</span>(item === <span class="string">'X'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不改变其他项</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：更新数组中的一个对象"><a href="#Redux：更新数组中的一个对象" class="headerlink" title="Redux：更新数组中的一个对象"></a>Redux：更新数组中的一个对象</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>这和上面的做法是一样的。唯一的不同是，我们需要构建一个新的对象，然后返回我们想要更新的那个对象的副本。</p>
<p>在这个例子中，我们有一个用户邮箱信息的数组。有一些用户的邮箱已经更换了，我们需要更新信息。我会展示用户的 id 和邮箱是如何作为 <code>action</code> 的一部分传入的，你当然也可以调整一下，接受来自其他地方的值（如果你没有在用 Redux）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        id: 1,</span></span><br><span class="line"><span class="comment">        email: 'jen@reynholmindustries.com',</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        id: 2,</span></span><br><span class="line"><span class="comment">        email: 'peter@initech.com',</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    action 中包含了新的信息：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    action = &#123;</span></span><br><span class="line"><span class="comment">      type: 'UPDATE_EMAIL'</span></span><br><span class="line"><span class="comment">      payload: &#123;</span></span><br><span class="line"><span class="comment">        userId: 2,  // Peter's ID</span></span><br><span class="line"><span class="comment">        newEmail: 'peter@construction.co'</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 找到 id 对应的那一项</span></span><br><span class="line">    <span class="keyword">if</span>(item.id === action.payload.userId) &#123;</span><br><span class="line">      <span class="comment">// 返回一个新的对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,  <span class="comment">// 复制原本的 item</span></span><br><span class="line">        email: action.payload.newEmail  <span class="comment">// 替换邮箱地址</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不改变其他项</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：在数组中间插入一项"><a href="#Redux：在数组中间插入一项" class="headerlink" title="Redux：在数组中间插入一项"></a>Redux：在数组中间插入一项</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>数组的 <code>.splice</code> 方法可以在数组中间插入一项，但是也会改变数组本身。</p>
<p>既然我们不想改变原始数组，我们可以先创建一个副本（用 <code>.slice</code>），然后用 <code>.splice</code> 在副本的中间插入一项。</p>
<p>另一种方法是，先复制新元素前面的所有元素，然后插入新的一项，然后复制新元素后面的所有元素。但是这样很容易把序号搞错。</p>
<p>专业提示：这里是很容易犯错的，需要编写单元测试。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [1, 2, 3, 5, 6]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newItem = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个副本</span></span><br><span class="line">  <span class="keyword">const</span> newState = state.slice()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在数组中间插入新的一项</span></span><br><span class="line">  newState.splice(<span class="number">3</span>, <span class="number">0</span>, newItem)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newState</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 你也可以这样做：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  return [                // 创建一个新的数组</span></span><br><span class="line"><span class="comment">    ...state.slice(0, 3), // 复制没有改变的前三项</span></span><br><span class="line"><span class="comment">    newItem,              // 插入新的一项</span></span><br><span class="line"><span class="comment">    ...state.slice(3)     // 复制剩下的，从 3 开始</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：按照-index-更新数组中的一项"><a href="#Redux：按照-index-更新数组中的一项" class="headerlink" title="Redux：按照 index 更新数组中的一项"></a>Redux：按照 index 更新数组中的一项</h2><p>（这不是 Redux 特有的，同样的方法也适用于组件中的 state。）</p>
<p>我们可以使用数组的 <code>.map</code> 方法为该 index 返回一个新的值，并保持其他项不变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [1, 2, 'X', 4]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 替换 index 为 2 的值</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不改变其他项</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redux：使用-filter-从数组中移除元素"><a href="#Redux：使用-filter-从数组中移除元素" class="headerlink" title="Redux：使用 filter 从数组中移除元素"></a>Redux：使用 <code>filter</code> 从数组中移除元素</h2><p>数组的 <code>.filter</code> 方法会调用你提供的函数，传入数组中的每一项。它会返回一个新的数组，只包括你的函数返回 true 的项目。</p>
<p>如果有一个 N 项的数组，你只想保留一部分，使用 <code>.filter</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    state = [1, 2, 'X', 4]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item === <span class="string">'X'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Redux 文档<a href="https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns" target="_blank" rel="noopener">不可变的更新模式</a>的部分中还有其他好的技巧。</p>
<h2 id="使用-Immer-轻松更新-state"><a href="#使用-Immer-轻松更新-state" class="headerlink" title="使用 Immer 轻松更新 state"></a>使用 Immer 轻松更新 state</h2><p>如果你因为上面不可变更新状态的代码想要尖叫着逃跑，我不会怪你的。</p>
<p>深层嵌套的对象更新难阅读，难书写，还难以写对。单元测试在此时十分有必要，但就算这样也不能让这种代码变得好写好读。</p>
<p>幸好有一个库可以帮助我们。使用 Michael Weststrate 写的 <a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a>，你可以写你熟悉又喜欢的可变代码，<code>[].push</code>、<code>[].pop</code> 还有 <code>=</code> 之类你都可以用——Immer 会魔术般接管代码，生产出完美的不可变更新。</p>
<p>这个真的很厉害。让我们看看它是怎么回事：</p>
<p>首先，你需要安装 Immer。（只有 2K，小但是很厉害。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add immer</span><br></pre></td></tr></table></figure>
<p>然后，你需要从 Immer 引入 <code>produce</code> 函数。它只有这一个出口。这个函数就是它做的所有事。多么棒、美好而专注。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">'immer'</span></span><br></pre></td></tr></table></figure>
<p>顺便一提，它的名字叫“produce”是因为它创造出了新的值，这个名字与“reduce”正相反。这里有一个他们最初讨论名字的 <a href="https://github.com/mweststrate/immer/issues/24" target="_blank" rel="noopener">issue</a>。</p>
<p>这样，你就可以使用 <code>produce</code> 函数为自己创造出一个小小的可变游乐场，你做出的所有改变都会被 JS 中转的魔法所处理。以下是对比，先是直接用 JS 更新一个嵌套在对象内部的值，然后是用 Immer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  State 的样子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  state = &#123;</span></span><br><span class="line"><span class="comment">    houses: &#123;</span></span><br><span class="line"><span class="comment">      gryffindor: &#123;</span></span><br><span class="line"><span class="comment">        points: 15</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      ravenclaw: &#123;</span></span><br><span class="line"><span class="comment">        points: 18</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      hufflepuff: &#123;</span></span><br><span class="line"><span class="comment">        points: 7</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      slytherin: &#123;</span></span><br><span class="line"><span class="comment">        points: 5</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plainJsReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 给拉文克劳加三分</span></span><br><span class="line">  <span class="comment">// 学院名存在变量中</span></span><br><span class="line">  <span class="keyword">const</span> key = <span class="string">'ravenclaw'</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state, <span class="comment">// 复制 state</span></span><br><span class="line">    houses: &#123;</span><br><span class="line">      ...state.houses, <span class="comment">// 复制学院</span></span><br><span class="line">      [key]: &#123;</span><br><span class="line">        ...state.houses[key],  <span class="comment">// 复制该学院的全部属性</span></span><br><span class="line">        points: state.houses[key].points + <span class="number">3</span>   <span class="comment">// 更新 points 属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immerifiedReducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="string">'ravenclaw'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// produce 接受原本的 state，以及一个 function</span></span><br><span class="line">  <span class="comment">// 它会调用这个 function，并向其中传入一个草稿版本的 state</span></span><br><span class="line">  <span class="keyword">return</span> produce(state, draft =&gt; &#123;</span><br><span class="line">    <span class="comment">// 随便改这个草稿</span></span><br><span class="line">    draft.houses[key].points += <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改过的草稿会被自动 return，不需要手动 return 任何东西</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对-React-组件中的-state-使用-Immer"><a href="#对-React-组件中的-state-使用-Immer" class="headerlink" title="对 React 组件中的 state 使用 Immer"></a>对 React 组件中的 state 使用 Immer</h2><p>Immer 对于组件中的 state 也很有用——通过函数形式的 setState。</p>
<p>你可能已经知道 React 的 <code>setState</code> 有一个函数形式，可以接受一个函数，并向这个函数传入当前的 state。这个函数会返回新的 state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">onIncrementClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 普通形式</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数形式</span></span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Immer 的 <code>produce</code> 方法可以被作为 state 的更新函数。你可能会注意到，在这种情况下调用 <code>produce</code> 只传入一个参数——更新函数——而不像 reducer 的例子里一样传入两个参数 <code>(state, draft =&gt; {})</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onIncrementClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(produce(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">    draft.count += <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逐渐采用-Immer"><a href="#逐渐采用-Immer" class="headerlink" title="逐渐采用 Immer"></a>逐渐采用 Immer</h2><p>Immer 的优点是，它非常小而专注（只暴露出一个函数，用于创建新的 state），很容易将其加入到现有的代码库中进行尝试。</p>
<p>Immer 也向下兼容已有的 Redux reducers。如果你把已有的 <code>switch/case</code> 包在 Immer 的 <code>produce</code> 函数中，你对 reducers 的测试仍都可以通过。</p>
<p>之前我展示过，传递给 <code>produce</code> 的更新函数可以只返回 <code>undefined</code>，<code>produce</code> 会自动收集你对于 <code>draft</code> 的更新。我没有提到的是，其实更新函数也可以返回一个全新的 state，只要你并没有对 <code>draft</code> 进行过更改。</p>
<p>也就是说，已有的会返回全新 state 的 Redux reducers，也可以被包在 Immer 的 <code>produce</code> 方法中，效果是一样的。因此，你可以在你有空的时候慢慢替换难以阅读的不可变代码。查看官方例子：<a href="https://github.com/mweststrate/immer#returning-data-from-producers" target="_blank" rel="noopener">从 producers 返回数据的不同方法</a>。</p>
<h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://daveceddia.com/react-redux-immutability-guide/" target="_blank" rel="noopener">Immutability in React and Redux: The Complete Guide</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/React-js/" rel="tag"># React.js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/20/rem布局在webview中页面错乱/" rel="next" title="rem布局在webview中页面错乱">
                <i class="fa fa-chevron-left"></i> rem布局在webview中页面错乱
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/05/关于我的项目为什么使用又剥离了Redux/" rel="prev" title="关于我的项目为什么使用又剥离了Redux">
                关于我的项目为什么使用又剥离了Redux <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="泉先">
          <p class="site-author-name" itemprop="name">泉先</p>
           
              <p class="site-description motion-element" itemprop="description">今天我有变得更厉害一点吗！>v<</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变性是什么"><span class="nav-number">1.</span> <span class="nav-text">不可变性是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#改变（mutation）的代码示例"><span class="nav-number">2.</span> <span class="nav-text">改变（mutation）的代码示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变性的规则"><span class="nav-number">3.</span> <span class="nav-text">不可变性的规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是“副作用”"><span class="nav-number">4.</span> <span class="nav-text">什么是“副作用”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#会改变的-JS-数组方法"><span class="nav-number">5.</span> <span class="nav-text">会改变的 JS 数组方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯函数只能调用纯函数"><span class="nav-number">6.</span> <span class="nav-text">纯函数只能调用纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯函数版本的-giveAwesomePowers"><span class="nav-number">7.</span> <span class="nav-text">纯函数版本的 giveAwesomePowers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯函数返回全新的对象"><span class="nav-number">8.</span> <span class="nav-text">纯函数返回全新的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-更喜欢不可变性"><span class="nav-number">9.</span> <span class="nav-text">React 更喜欢不可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变性对于-PureComponents-而言很重要"><span class="nav-number">10.</span> <span class="nav-text">不可变性对于 PureComponents 而言很重要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用相等在-JavaScript-中是如何运行的？"><span class="nav-number">11.</span> <span class="nav-text">引用相等在 JavaScript 中是如何运行的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么不深入比较是否相等呢？"><span class="nav-number">12.</span> <span class="nav-text">为什么不深入比较是否相等呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-能阻止改变吗？"><span class="nav-number">13.</span> <span class="nav-text">const 能阻止改变吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-Redux-中要如何更新-state-呢？"><span class="nav-number">14.</span> <span class="nav-text">在 Redux 中要如何更新 state 呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#…-扩展操作符"><span class="nav-number">15.</span> <span class="nav-text">… 扩展操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新-state-的诀窍"><span class="nav-number">16.</span> <span class="nav-text">更新 state 的诀窍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在-React-中更新组件中的-state"><span class="nav-number">16.1.</span> <span class="nav-text">在 React 中更新组件中的 state</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：更新对象"><span class="nav-number">17.</span> <span class="nav-text">Redux：更新对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux-更新对象中的对象"><span class="nav-number">18.</span> <span class="nav-text">Redux: 更新对象中的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：按照属性名更新对象"><span class="nav-number">19.</span> <span class="nav-text">Redux：按照属性名更新对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：在数组头部插入一项"><span class="nav-number">20.</span> <span class="nav-text">Redux：在数组头部插入一项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：在数组尾部插入一项"><span class="nav-number">21.</span> <span class="nav-text">Redux：在数组尾部插入一项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：使用-map-更新数组中的一项"><span class="nav-number">22.</span> <span class="nav-text">Redux：使用 map 更新数组中的一项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：更新数组中的一个对象"><span class="nav-number">23.</span> <span class="nav-text">Redux：更新数组中的一个对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：在数组中间插入一项"><span class="nav-number">24.</span> <span class="nav-text">Redux：在数组中间插入一项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：按照-index-更新数组中的一项"><span class="nav-number">25.</span> <span class="nav-text">Redux：按照 index 更新数组中的一项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux：使用-filter-从数组中移除元素"><span class="nav-number">26.</span> <span class="nav-text">Redux：使用 filter 从数组中移除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Immer-轻松更新-state"><span class="nav-number">27.</span> <span class="nav-text">使用 Immer 轻松更新 state</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对-React-组件中的-state-使用-Immer"><span class="nav-number">28.</span> <span class="nav-text">对 React 组件中的 state 使用 Immer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逐渐采用-Immer"><span class="nav-number">29.</span> <span class="nav-text">逐渐采用 Immer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原文"><span class="nav-number">30.</span> <span class="nav-text">原文</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">泉先</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
