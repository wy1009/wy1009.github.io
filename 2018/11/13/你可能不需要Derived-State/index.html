<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="JavaScript,React.js,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="React 16.4 为 getDerivedStateFromProps 修复了一个 bug，这个 bug 会导致一些在 React 组件中存在的 bug 不断重现。如果本次更新暴露了你的应用正在使用反模式（不推荐的做法）且在本次更新后可能出现问题，我们对此感到抱歉。在这篇博文中，我们会解释一些使用 derived state 时常见的反模式和我们更推荐的替代做法。 在很长一段时间里，如果想在">
<meta name="keywords" content="JavaScript,React.js">
<meta property="og:type" content="article">
<meta property="og:title" content="你可能不需要 Derived State">
<meta property="og:url" content="http://yoursite.com/2018/11/13/你可能不需要Derived-State/index.html">
<meta property="og:site_name" content="不会化妆的写手&lt;br&gt;不是好程序员">
<meta property="og:description" content="React 16.4 为 getDerivedStateFromProps 修复了一个 bug，这个 bug 会导致一些在 React 组件中存在的 bug 不断重现。如果本次更新暴露了你的应用正在使用反模式（不推荐的做法）且在本次更新后可能出现问题，我们对此感到抱歉。在这篇博文中，我们会解释一些使用 derived state 时常见的反模式和我们更推荐的替代做法。 在很长一段时间里，如果想在">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/React-16-4-lifecycle.png">
<meta property="og:updated_time" content="2020-06-30T14:04:59.935Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你可能不需要 Derived State">
<meta name="twitter:description" content="React 16.4 为 getDerivedStateFromProps 修复了一个 bug，这个 bug 会导致一些在 React 组件中存在的 bug 不断重现。如果本次更新暴露了你的应用正在使用反模式（不推荐的做法）且在本次更新后可能出现问题，我们对此感到抱歉。在这篇博文中，我们会解释一些使用 derived state 时常见的反模式和我们更推荐的替代做法。 在很长一段时间里，如果想在">
<meta name="twitter:image" content="http://yoursite.com/images/React-16-4-lifecycle.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/13/你可能不需要Derived-State/">





  <title>你可能不需要 Derived State | 不会化妆的写手<br>不是好程序员</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a17a483691d457feb9d048db3e29684c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不会化妆的写手<br>不是好程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/13/你可能不需要Derived-State/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="泉先">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不会化妆的写手<br>不是好程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">你可能不需要 Derived State</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-13T20:37:09+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/框架-库-工具/" itemprop="url" rel="index">
                    <span itemprop="name">框架/库/工具</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/框架-库-工具/React-js/" itemprop="url" rel="index">
                    <span itemprop="name">React.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>React 16.4 <a href="https://reactjs.org/blog/2018/05/23/react-v-16-4.html#bugfix-for-getderivedstatefromprops" target="_blank" rel="noopener">为 <code>getDerivedStateFromProps</code> 修复了一个 bug</a>，这个 bug 会导致一些在 React 组件中存在的 bug 不断重现。如果本次更新暴露了你的应用正在使用反模式（不推荐的做法）且在本次更新后可能出现问题，我们对此感到抱歉。在这篇博文中，我们会解释一些使用 derived state 时常见的反模式和我们更推荐的替代做法。</p>
<p>在很长一段时间里，如果想在 props 改变时更新 state，且不造成多余的渲染，我们只能依靠生命周期 <code>componentWillReceiveProps</code>。在 16.3 版本，<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes" target="_blank" rel="noopener">我们介绍了一种可以替代 <code>componentWillReceiveProps</code> 的生命周期—— <code>getDerivedStateFromProps</code></a> ——来更安全地解决同样的问题。与此同时，我们发现大家在使用这两种生命周期时存在很多错误的观念，也发现了一些会造成微妙而令人困扰的 bug 的反模式。16.4 版本中对 <code>getDerivedStateFromProps</code> 的 bugfix 使 derived state 更加可预料，因而误用它所产生的结果也更加容易被注意到。</p>
<blockquote>
<p><strong> 注意 </strong><br>本文描述的所有反模式都同时适用于旧的 <code>componentWillReceiveProps</code> 和新的 <code>getDerivedStateFromProps</code>。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么时候使用-derived-state"><a href="#什么时候使用-derived-state" class="headerlink" title="什么时候使用 derived state"></a>什么时候使用 derived state</h2><p><code>getDerivedStateFromProps</code> 只用于一个目的——让组件可以在 <strong>props 改变</strong>时更新内部的 state。我们之前的博文提供了一些例子，比如 <a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props" target="_blank" rel="noopener">基于改变中的 offset prop 记录当前的滚动方向</a> 或者 <a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change" target="_blank" rel="noopener">加载代码指定的外部数据</a>。</p>
<p>我们没有举很多例子，因为作为一个普遍的规则，<strong>应该尽量少而谨慎地使用 derived state。</strong>在 derived state 上出的问题，可以减少的无非两种：1. 无条件从 props 更新数据到 state；2. 不管 props 和 state 是否匹配都更新 state。（两种我们在下面都会详细讲。）</p>
<ul>
<li>如果你使用 derived state 是为了记录仅基于当前 props 的计算结果，你不需要 derived state。看看下面的 <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization" target="_blank" rel="noopener">试试 memoization</a>。</li>
<li>如果你无条件更新 state，或者不管 props 和 state 是否匹配都更新 state，那你的组件恐怕太经常重置 state 了。下面会详细讲。</li>
</ul>
<h2 id="使用-derived-state-时的常见-bug"><a href="#使用-derived-state-时的常见-bug" class="headerlink" title="使用 derived state 时的常见 bug"></a>使用 derived state 时的常见 bug</h2><p>术语“受控”和“非受控”通常指表格输入，但也可以用来描述组件的数据存在哪里。通过 props 传的数据可以被称为是“<strong>受控</strong>”的（因为父组件控制了数据），仅存在于内部 state 的数据可以被认为是“<strong>非受控</strong>”的（因为父组件不能直接改变它）。</p>
<p>使用 derived state 最常见的错误是把“受控”和“非受控”混在一起。在 state 同时被 derived state 和 <code>setState</code> 更新的时候，数据没有真实的单一来源。上面提到的 <a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change" target="_blank" rel="noopener">外部数据加载示例</a> 听起来可能类似，但在一些重要的方面并不相同。在加载示例中，对于作为来源的 props 和加载中的 state 都有干净的真实来源。当作为来源的 props 改变了，加载的 state <strong>总是</strong>都应该被重写。反过来，state 只会在 props <strong>改变</strong>时被重写，在重写之外的其他方面才会被组件本身管理。</p>
<p>不遵守这些约束中的任何一个都会出现问题，问题通常以两种形式出现。</p>
<h3 id="反模式：无条件把-props-复制到-state-上"><a href="#反模式：无条件把-props-复制到-state-上" class="headerlink" title="反模式：无条件把 props 复制到 state 上"></a>反模式：无条件把 props 复制到 state 上</h3><p>一个常见的错误观念是，<code>getDerivedStateFromProps</code> 和 <code>componentWillReceiveProps</code> 只在 props 改变的时候被调用。这两个生命周期其实会在父组件渲染的时候被调用，不管 props 是否和之前不一样。因此，使用这两个生命周期无条件重写 state 是不安全的。<strong>这样做会导致 state 更新丢失。</strong></p>
<p>让我们考虑一个例子来证明这个问题。以下是一个 <code>EmailInput</code> 组件，在 state 中“镜像”了一个 email prop：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.email &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  handleChange = event =&gt; &#123;</span></span><br><span class="line"><span class="xml">    this.setState(&#123; email: event.target.value &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  componentWillReceiveProps(nextProps) &#123;</span></span><br><span class="line"><span class="xml">    // 这里将擦掉所有本地的 state 更新</span></span><br><span class="line"><span class="xml">    // 不要这样做</span></span><br><span class="line"><span class="xml">    this.setState(&#123; email: nextProps.email &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>一开始，这个组件可能看起来没问题。state 被 props 指定的值初始化，当我们在 <code>&lt;input&gt;</code> 中打字的时候，state 会更新。但如果父组件渲染，我们在 <code>&lt;input&gt;</code> 中打的字就会丢失！（<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change" target="_blank" rel="noopener">demo</a>）即使我们在重置 state 之前对比 <code>nextProps.email !== this.state.email</code> 也是一样的。</p>
<p>在这个简单的例子中，增加 <code>shouldComponentUpdate</code> 使只有 email prop 改变的时候才渲染可以解决这个问题。然而在实践中，组件通常接受多个 props，其他 prop 的改变也会触发渲染，导致不正确的重置。方法和对象的 props 也经常被内联创建，使我们很难使 <code>shouldComponentUpdate</code> 仅在真正改变的时候返回 true。（<a href="https://codesandbox.io/s/jl0w6r9w59" target="_blank" rel="noopener">demo</a>）。因此， <code>shouldComponentUpdate</code> 最好被用于性能优化，而不是确定 derived state 的正确性。</p>
<p>希望现在大家已经清楚为什么不能无条件把 props 复制到 state 上了。在讲可能的解决方法之前，我们先来看看另一个造成问题的同类反模式：如果我们只在 email prop 改变的时候更新 state 会怎么样呢？</p>
<h3 id="反模式：当-props-改变的时候重置-state"><a href="#反模式：当-props-改变的时候重置-state" class="headerlink" title="反模式：当 props 改变的时候重置 state"></a>反模式：当 props 改变的时候重置 state</h3><p>继续上面的例子，我们可以只在 <code>props.email</code> 改变的时候更新 state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.email,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.email !== <span class="keyword">this</span>.props.email) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        email: nextProps.email,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>虽然上面的例子使用的是 <code>componentWillReceiveProps</code>，但道理在 <code>getDerivedStateFromProps</code> 中是一样的。</p>
</blockquote>
<p>这样就有了很大的改善。现在组件只会在 props 改变的时候才会删除我们输入的内容了。</p>
<p>这样仍旧有一个小问题。想象有一个使用上面这个组件的密码管理应用。当在使用同一个 email 的两个账户详情之间切换的时候，input 将不会重置。这是因为两个账户传入的 prop 是一样的。这会让用户感到很奇怪，如果有两个 email 相同的账户，一个账户详情中没有保存的内容会在另一个账户的详情中出现。（<a href="https://codesandbox.io/s/mz2lnkjkrx" target="_blank" rel="noopener">demo</a>）</p>
<p>这样设计很不好，但是我们却很容易犯。（<a href="https://twitter.com/brian_d_vaughn/status/959600888242307072" target="_blank" rel="noopener">我就曾经犯过</a>）幸运的是，有两个更好的解决方法。两种方法的关键都是，对于任何一点数据，我们都需要选择一个拥有它的组件作为真实的来源，并且避免在其他组件中复制它。让我们挨个看看这两种解决方法。</p>
<h2 id="更好的解决方法"><a href="#更好的解决方法" class="headerlink" title="更好的解决方法"></a>更好的解决方法</h2><h3 id="推荐：完全受控组件"><a href="#推荐：完全受控组件" class="headerlink" title="推荐：完全受控组件"></a>推荐：完全受控组件</h3><p>要避免上面提到的问题，一种方法是把 state 从组件中移除。如果 email prop 只作为 props 存在，那么我们就不需要担心和 state 有冲突。我们甚至可以把 <code>EmailInput</code> 转变为一个更轻量级的函数式组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmailInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;props.onChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;props.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种方法简化了我们的组件的实践，但如果我们仍旧想要存一个草稿值，父级表单组件需要手动做这件事。（<a href="https://codesandbox.io/s/7154w1l551" target="_blank" rel="noopener">点击查看这种模式的 demo</a>）（译者注：我觉得“草稿值”指的是用户正在操作而没有真正提交的值。）</p>
<h3 id="推荐：带-key-的完全不受控组件"><a href="#推荐：带-key-的完全不受控组件" class="headerlink" title="推荐：带 key 的完全不受控组件"></a>推荐：带 key 的完全不受控组件</h3><p>另一个解决方法是，让我们的组件完全拥有“草稿”的 email state。这样，组件能够始终接收一个 prop 作为初始值，但会忽视掉对于 prop 后续的更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">email</span>: <span class="keyword">this</span>.props.defaultEmail &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">email</span>: event.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.email&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了能在其他情况下使用的时候重置值（比如我们设想的密码管理应用的情况），我们可以使用 React 的特殊属性：<code>key</code>。当 <code>key</code> 改变的时候，React 会<a href="https://reactjs.org/docs/reconciliation.html#keys" target="_blank" rel="noopener">创建一个新的组件实例，而不是更新目前的这一个</a>。key 通常被用于动态列表，但在这种情况下也很有用。在我们的例子中，我们可以使用 user ID 作为key，使得每次新用户被选择时都重新创建 email input。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EmailInput</span> <span class="attr">defaultEmail</span>=<span class="string">&#123;this.props.user.email&#125;</span> <span class="attr">key</span>=<span class="string">&#123;this.props.user.id&#125;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每次 ID 改变，<code>EmailInput</code> 组件都会被重新创建，它的 state 也会被重置为 <code>defaultValue</code> 的值。（<a href="https://codesandbox.io/s/6v1znlxyxn" target="_blank" rel="noopener">点击查看这种模式的 demo</a>）。用这种方法，你不需要给每一个 input 增加 <code>key</code>，直接给整个 form 表单加一个 <code>key</code> 恐怕更合理。每次 key 改变，所有在 form 表单里的组件都会被重新创建，state 也被更新为初始值。</p>
<p>在大多数情况下，如果需要重置 state，这都是最好的方法。</p>
<blockquote>
<p><strong>注意</strong><br>虽然这种方法听起来很慢，但是性能差距其实是微不足道的。如果组件在更新时有很重的逻辑，使用 key 甚至可以更快，因为该子树的 diff 被绕过了。</p>
</blockquote>
<h4 id="可替代方法-1：使用一个-id-prop-重置非受控组件"><a href="#可替代方法-1：使用一个-id-prop-重置非受控组件" class="headerlink" title="可替代方法 1：使用一个 id prop 重置非受控组件"></a>可替代方法 1：使用一个 id prop 重置非受控组件</h4><p>如果 <code>key</code> 因为某些原因不起作用（比如组件初始化的代价非常昂贵），一个可行的笨方法是在 <code>getDerviedStateFromProps</code> 中观察 user id 的更改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail,</span><br><span class="line">    prevPropsUserID: <span class="keyword">this</span>.props.userID,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.userID !== state.prevPropsUserID) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        prevPropsUserID: props.userID,</span><br><span class="line">        email: props.defaultEmail,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做也具有灵活性，能够只重置一部分内部的 state。（<a href="https://codesandbox.io/s/rjyvp7l3rq" target="_blank" rel="noopener">点击查看这种模式的 demo</a>）</p>
<blockquote>
<p><strong>注意</strong><br>虽然上面的例子展示的是 <code>getDerivedStateFromProps</code>，但同样的方法也可以被用于 <code>componentWillReceiveProps</code>。</p>
</blockquote>
<h4 id="可替代方法-2：使用实例方法重置非受控组件"><a href="#可替代方法-2：使用实例方法重置非受控组件" class="headerlink" title="可替代方法 2：使用实例方法重置非受控组件"></a>可替代方法 2：使用实例方法重置非受控组件</h4><p>在更加少见的情况下，你可能需要重置 state，但是没有合适的 ID 作为 <code>key</code>。一个解决方案是在每次想要重置的时候，利用随机值或者自增的数字作为 <code>key</code>。另一个可行的方法是，暴露一个实例方法来命令式地重置内部的 state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    email: <span class="keyword">this</span>.props.defaultEmail,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetEmailForNewUsers(newEmail) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      email: newEmail,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，父组件可以<a href="https://reactjs.org/docs/glossary.html#refs" target="_blank" rel="noopener">使用 ref 来调用这个方法</a>。（<a href="https://codesandbox.io/s/l70krvpykl" target="_blank" rel="noopener">点击查看这种模式的 demo</a>）</p>
<p>Ref 在像这样的例子里很有用，但是一般来讲，我们建议少使用 Ref。即使是在这个 demo 中，这种命令式的方法也不理想，因为会造成两次渲染，而不是不使用时的一次。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下，当设计一个组件的时候，很重要的是决定它的数据是受控的还是非受控的。</p>
<p>比起试图<strong>在 state 中“镜像” prop</strong>，不如使组件<strong>受控</strong>，在父组件的 state 中合并两个不同的值。比如，比起子组件接收“用于提交的”（committed） <code>props.value</code> 并追踪一个“草稿”（draft）的 <code>state.value</code>，不如让父组件同时有 <code>state.draftValue</code> 和 <code>state.committedValue</code> 并直接控制子组件的值。这使得数据流更加明确而可预计。</p>
<p>对于<strong>非受控</strong>组件，如果你试图在一个特别的 prop（通常是 ID）改变时重置 state，你可以选择：</p>
<ul>
<li><strong>推荐：使用 key 属性重置所有内部的 state。</strong></li>
<li>可替代 1：仅重置特定的 state 字段，监听特殊值的变动（比如 <code>props.userID</code>）。</li>
<li>可替代 2：你也可以考虑退而求其次，用 refs 的命令式实例方法。</li>
</ul>
<h2 id="要不要试试-memoization-呢？"><a href="#要不要试试-memoization-呢？" class="headerlink" title="要不要试试 memoization 呢？"></a>要不要试试 memoization 呢？</h2><p>我们也看到 derived state 被用于确认某些用于渲染的值仅在 input 改变的时候重新计算。这种方法被称为 <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="noopener"><code>memoization</code></a>。</p>
<p>使用 derived state 做缓存（memoization）不一定不好，但通常不是最优解。管理 derived state 存在固有的复杂性，且每增加一个属性都会更加复杂。比如，如果我们给组件的 state 增加第二个 derived 字段，那么我们需要分别追踪这两者的更改。</p>
<p>来看一个例子，一个组件接收一个 prop——一个列表——并根据用户输入的查询字段渲染匹配的项。我们可以使用 derived state 储存过滤后的列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    filterText: <span class="string">''</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，这个例子不是推荐的用法</span></span><br><span class="line">  <span class="comment">// 在这个例子下面有我们推荐的方法</span></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      props.list !== state.prevPropsList ||</span><br><span class="line">      state.prevFilterText !== state.filterText</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        prevPropsList: props.list,</span><br><span class="line">        prevFilterText: state.filterText,</span><br><span class="line">        filteredList: props.list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.text.includes(state.filterText))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125;&gt;</span><br><span class="line">        &lt;ul&gt;&#123;<span class="keyword">this</span>.state.filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;)&#125;&lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种做法避免了对 <code>filteredList</code> 不必要的重新计算。但是这种做法比正常要复杂得多。为了正确地更新过滤后的列表，需要同时分别追踪和监听 prop 和 state 中的变化。在这个例子中，我们可以用 <code>PureComponent</code> 简化，把过滤操作移动到 render 方法中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯组件只在有 state 或者 prop 改变的时候重新渲染</span></span><br><span class="line"><span class="comment">// 对 state 和 prop 做浅比较来决定是否改变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// state 只需要管理当前的 filter text 值</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    filterText: <span class="string">''</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> filteredList = <span class="keyword">this</span>.props.list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.text.includes(<span class="keyword">this</span>.state.filterText))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125; /&gt;</span><br><span class="line">        &lt;ul&gt;&#123;filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;)&#125;&lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的方法比 derived state 的版本更加干净简单。在个别情况下，这不够好——对很大的列表来说，过滤可能会慢，而在其他 prop 改变的时候，<code>PureComponent</code> 不会阻止渲染。为了解决这两个问题，我们可以添加 memoization 避免对列表不必要的重新过滤：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">'memoize-one'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">filterText</span>: <span class="string">''</span> &#125;</span><br><span class="line"></span><br><span class="line">  filter = memoize(</span><br><span class="line">    (list, filterText) =&gt; list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.text.includes(filterText))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">filterText</span>: event.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> filteredList = <span class="keyword">this</span>.filter(<span class="keyword">this</span>.props.list, <span class="keyword">this</span>.state.filterText)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input onChange=&#123;<span class="keyword">this</span>.handleChange&#125; value=&#123;<span class="keyword">this</span>.state.filterText&#125;&gt;</span><br><span class="line">        &lt;ul&gt;&#123;filteredList.map(<span class="function"><span class="params">item</span> =&gt;</span> &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;<span class="regexp">/li&gt;)&#125;&lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样简单得多，且表现得和 derived state 版本一模一样。</p>
<p>当使用 memoization 时，记住一些限制：</p>
<ol>
<li>在大多数情况下，你需要<strong>把用来做缓存的方法加到组件实例上</strong>。这防止一个组件的多个实例互相重置对方缓存的值。</li>
<li>通常，为了防止随着时间推移内存泄露，你会想要用具有<strong>缓存大小限制</strong>的助手。（在上面的例子中，我们使用 <code>memoize-one</code>，因为它只缓存最近的参数和结果。）</li>
<li>如果 <code>props.list</code> 在每次父组件渲染的时候都会重新创建，那么本节中显示的任何方法都不会起作用。但在大多数情况下，这种设置是合适的。</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在实际应用中，组件通常同时包含受控行为和不受控行为。这是没关系的！如果每一个值都有一个清晰的真实来源，你就可以避免上面的反模式。</p>
<p>值得重新考虑的是，<code>getDerivedStateFromProps</code>（以及一般的派生状态）是一种高级功能，因为其复杂性，应该少而谨慎地使用。如果你的用例不在这些模式中，请在 <a href="https://github.com/reactjs/reactjs.org/issues/new" target="_blank" rel="noopener">Github</a> 或 <a href="https://twitter.com/reactjs" target="_blank" rel="noopener">Twitter</a> 中分享给我们！</p>
<h2 id="译者附"><a href="#译者附" class="headerlink" title="译者附"></a>译者附</h2><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p>来自 React 官方博客，<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener">你可能不需要派生状态</a>。</p>
<h3 id="以上文章综合总结"><a href="#以上文章综合总结" class="headerlink" title="以上文章综合总结"></a>以上文章综合总结</h3><p>这样说可能不太好，但我觉得这篇文章的逻辑还是有一点混乱的……</p>
<p>最前面，需求仿佛还是 在 prop 更新的时候，state 也需要做出反应。稍往后，作者就根据自己的业务需求，把代码上的需求更改为了“prop 只需要作为 state 的初始化数值，不需要随 prop 更新做出反应”。所以你会发现，它推荐的方法并不能真正替代反模式实现的效果，因为在 <code>key</code> 相同的情况下，推荐做法无法做到在 props 每次更新时都做出响应。</p>
<p>你可以说，作者的需求就是这样的呀。但是，提出 <code>key</code> 方法是根据作者自己假设的另一个需求，即存在切换用户的需求。既然作者可以假设能够切换用户，为什么就不能假设，比如，外部需要一个按钮重置所有组件的 email 值（但不影响其他值）呢？这样 <code>key</code> 方法不就行不通了吗？</p>
<p>哪怕切换用户是一开始就提出的，我也认为不妥。大家看 React 官方博客的文章，寻求的必然是通用做法，而不是完全根据一个狭窄的实际用例去区分“好方法”和“坏方法”。</p>
<p>因此，我觉得第二种反模式，实际上不能说是反模式。可以注意一下，第二种“反模式”，即在 props 更新时比较新旧 props，实际上与 <code>key</code> 推荐方法的第一种替代是同样的做法。也就是说，在 props 更新时比较新旧 props 并不是“反模式”，在可以切换用户的情况下，比较 email 值，而不是比较 user ID 的值，这才是反模式。</p>
<p>在我看来，后面追加的 memoization 章节，这才是真正可以用于实现“某项 prop/state 更改（而不是如切换用户等情况下的整体更改）后才做某些操作”的需求。</p>
<p>memoization 的核心其实就是将最终结果缓存起来（对应 memoization 的反模式：分别缓存单独的 state/prop），在组件需要更新的情况下（state/prop 改变或是父组件渲染），组件本身还是会更新，但其应该渲染的值是被缓存起来的，如果传入的参数一样，就直接返回值，不需要重新做重复的计算/请求等操作。</p>
<h3 id="React-16-4-新的生命周期"><a href="#React-16-4-新的生命周期" class="headerlink" title="React 16.4+ 新的生命周期"></a>React 16.4+ 新的生命周期</h3><p><img src="/images/React-16-4-lifecycle.png" alt="React 16.4+ 新的生命周期" title="React 16.4+ 新的生命周期"></p>
<h3 id="关于如何完全取代-componentWillReceiveProps"><a href="#关于如何完全取代-componentWillReceiveProps" class="headerlink" title="关于如何完全取代 componentWillReceiveProps"></a>关于如何完全取代 <code>componentWillReceiveProps</code></h3><p>根据 React 官方文档，有以下几点：</p>
<ol>
<li>如果你需要在 props 改变后表现某种副作用（比如，请求发送或动画），使用 <a href="https://reactjs.org/docs/react-component.html#componentdidupdate" target="_blank" rel="noopener"><code>componentDidUpdate</code></a> 生命周期代替。</li>
<li>如果你想要仅在 prop 改变的时候重新计算某些数据，使用 memoization 代替。</li>
<li>如果你想要在 prop 改变的时候重置某些 state，考虑使组件完全受控或完全不受控（并使用 <code>key</code>）代替。</li>
<li>在十分少见的情况下，你可能想使用 <a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops" target="_blank" rel="noopener"><code>getDerivedStateFromProps</code></a> 作为最后的选择。</li>
</ol>
<p>综合本篇文章，我认为第三条是不完全正确的。完全受控 + key 根本做不到在 props 某项改变的时候更新，只能做到在 props 整体改变，新数据与之前没有关联的时候（比如对用户的管理系统，切换了用户），整体更新。</p>
<p>最终总结，我认为，官方提供的在 props 改变时更新的方法有以下几点：</p>
<ol>
<li>使用 <code>componentDidUpdate</code> 代替；</li>
<li>干脆绕过去，把需要在 props 改变时更新的操作移到父组件，这样不需要在子组件比较更新，直接把最终结果下发到子组件即可；</li>
<li>如果 props 是整体全部改变，数据与之前没有关联（比如用户管理系统，切换了用户，id 都不同了），利用 id 作为 <code>key</code>，将整个组件重置；</li>
<li>memoization；</li>
<li>万不得已再使用的 <code>getDerivedStateFromProps</code>。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/React-js/" rel="tag"># React.js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/05/关于我的项目为什么使用又剥离了Redux/" rel="next" title="关于我的项目为什么使用又剥离了Redux">
                <i class="fa fa-chevron-left"></i> 关于我的项目为什么使用又剥离了Redux
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/02/a-cartoon-intro-to-fiber/" rel="prev" title="对 Fiber 的介绍">
                对 Fiber 的介绍 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="泉先">
          <p class="site-author-name" itemprop="name">泉先</p>
           
              <p class="site-description motion-element" itemprop="description">今天我有变得更厉害一点吗！>v<</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么时候使用-derived-state"><span class="nav-number">1.</span> <span class="nav-text">什么时候使用 derived state</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-derived-state-时的常见-bug"><span class="nav-number">2.</span> <span class="nav-text">使用 derived state 时的常见 bug</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#反模式：无条件把-props-复制到-state-上"><span class="nav-number">2.1.</span> <span class="nav-text">反模式：无条件把 props 复制到 state 上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反模式：当-props-改变的时候重置-state"><span class="nav-number">2.2.</span> <span class="nav-text">反模式：当 props 改变的时候重置 state</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更好的解决方法"><span class="nav-number">3.</span> <span class="nav-text">更好的解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐：完全受控组件"><span class="nav-number">3.1.</span> <span class="nav-text">推荐：完全受控组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐：带-key-的完全不受控组件"><span class="nav-number">3.2.</span> <span class="nav-text">推荐：带 key 的完全不受控组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可替代方法-1：使用一个-id-prop-重置非受控组件"><span class="nav-number">3.2.1.</span> <span class="nav-text">可替代方法 1：使用一个 id prop 重置非受控组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可替代方法-2：使用实例方法重置非受控组件"><span class="nav-number">3.2.2.</span> <span class="nav-text">可替代方法 2：使用实例方法重置非受控组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要不要试试-memoization-呢？"><span class="nav-number">4.</span> <span class="nav-text">要不要试试 memoization 呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">5.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#译者附"><span class="nav-number">6.</span> <span class="nav-text">译者附</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原文"><span class="nav-number">6.1.</span> <span class="nav-text">原文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以上文章综合总结"><span class="nav-number">6.2.</span> <span class="nav-text">以上文章综合总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-16-4-新的生命周期"><span class="nav-number">6.3.</span> <span class="nav-text">React 16.4+ 新的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于如何完全取代-componentWillReceiveProps"><span class="nav-number">6.4.</span> <span class="nav-text">关于如何完全取代 componentWillReceiveProps</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">泉先</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
